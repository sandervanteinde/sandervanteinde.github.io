self.webpackChunk([19],{zqjj:function(e,n,t){"use strict";t.r(n),t.d(n,"dayNineteenPartOne",function(){return r});const r="const map = new Map<number, Rule>();\nfunction getRule(ruleId: number): Rule {\n  const rule = map.get(ruleId);\n  if(!rule) {\n    throw new Error(`Rule id not found: ${ruleId}`);\n  }\n  return rule;\n}\ninterface Rule { isValid(input: string): boolean; readonly length: number }\nclass LetterRule implements Rule {\n  readonly length = 1;\n  constructor(private readonly _letter: string) { }\n  isValid(input: string) {\n    return this._letter === input;\n  }\n}\n\nclass RuleReference implements Rule {\n  get length(): number {  return getRule(this._reference).length; }\n  constructor(private readonly _reference: number) {\n    if(!this._reference) throw new Error(`Reference should be value. Got: ${_reference}`);\n  }\n  isValid(input: string): boolean { return getRule(this._reference).isValid(input); }\n}\n\nclass OrRule implements Rule {\n  get length(): number { \n    return this._leftRuleNumber.length;\n  }\n  constructor(private readonly _leftRuleNumber: Rule, private readonly _rightRuleNumber: Rule) {\n  }\n\n  isValid(input: string): boolean {\n    return this._leftRuleNumber.isValid(input) || this._rightRuleNumber.isValid(input);\n  }\n}\n\nclass CombinationRule implements Rule {\n  get length(): number { \n    return getRule(this._leftRuleNumber).length + getRule(this._rightRuleNumber).length;\n  }\n\n  constructor(private readonly _leftRuleNumber: number, private readonly _rightRuleNumber: number) {\n    if(!_leftRuleNumber || !_rightRuleNumber){\n       throw new Error(`Rule number(s) are invalid: ${_leftRuleNumber} ${_rightRuleNumber}`);\n    }\n  }\n\n  isValid(input: string): boolean {\n    const leftRule = getRule(this._leftRuleNumber);\n    const rightRule = getRule(this._rightRuleNumber);\n    const leftRuleLength = leftRule.length;\n    if (leftRuleLength + rightRule.length !== input.length) return false;\n    return leftRule.isValid(input.substr(0, leftRuleLength)) && rightRule.isValid(input.substr(leftRuleLength));\n  }\n}\n\nconst rawInput = new Map<number, string>();\nconst lines = [] as Array<string>;\nconst reader = new MyFileReader(input);\nconst lineMatch = /^(d+): (.+)$/;\nconst inputMatch = /^[ab]+$/;\nreader.readLineByLine(line => {\n  const match = lineMatch.exec(line);\n  const input = inputMatch.exec(line);\n  if(!match && !input) throw new Error(`Invalid parsed line: ${line}`);\n  if(match) rawInput.set(Number(match[1]), match[2]);\n  if(input) lines.push(line);\n});\n\nfunction parseRawRule(rule: string): Rule {\n  if(rule.indexOf('\"') !== -1) {\n    return new LetterRule(JSON.parse(rule) as string);\n  }\n  const entries = rule.split(' | ')\n    .map(ruleIds => \n      ruleIds.split(' ')\n        .map(Number)\n    );\n  function parseEntry(entry: number[]): Rule {\n    switch(entry.length) {\n      case 1:\n        return new RuleReference(entry[0]);\n      case 2:\n        return new CombinationRule(entry[0], entry[1]);\n      default: throw new Error('Found more then 3 numbers in a single operation')\n    }\n  }\n\n  if(entries.length === 0 || entries.length > 2) throw new Error('This should never happened');\n  return entries.length === 1 \n    ? parseEntry(entries[0])\n    : new OrRule(\n      parseEntry(entries[0]),\n      parseEntry(entries[1])\n    );\n\n}\n\nfor(const [ruleId, rawRule] of rawInput) {\n  map.set(ruleId, parseRawRule(rawRule));\n}\n\nconst ruleZero = getRule(0);\n\nlet sum = 0;\nfor(const line of lines) {\n  if(ruleZero.isValid(line)) sum++;\n}\n\nreturn sum;"}});