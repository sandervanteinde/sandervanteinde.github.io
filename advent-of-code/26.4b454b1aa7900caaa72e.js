(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{WCrJ:function(n,e,a){"use strict";a.r(e),a.d(e,"daySeventeenPartOne",function(){return r});const r="type CoordinateArray = [x: number, y: number, z: number];\n\nfunction getOrAddValue<TKey, TValue>(map: Map<TKey, TValue>, key: TKey, createFn: () => TValue): TValue {\n  let existingValue = map.get(key);\n  if (existingValue === undefined) {\n    existingValue = createFn();\n    map.set(key, existingValue);\n  }\n  return existingValue;\n}\n\nclass MinMaxTracker {\n  private _min = Number.MAX_SAFE_INTEGER;\n  private _max = Number.MIN_SAFE_INTEGER;\n  get min(): number { return this._min; }\n  get max(): number { return this._max; }\n\n  update(val: number): void {\n    this._min = Math.min(val, this._min);\n    this._max = Math.max(val, this._max);\n  }\n}\n\nclass Grid {\n  // Map is x, y, z.\n  private _gridEntries = new Map<number, Map<number, Map<number, boolean>>>();\n  private _surroundingNodes = new Map<number, Map<number, Map<number, number>>>();\n  private _changes = new Map<number, Map<number, Map<number, boolean>>>();\n  private _xMinMax = new MinMaxTracker();\n  private _yMinMax = new MinMaxTracker();\n  private _zMinMax = new MinMaxTracker();\n\n  addActivePoint(...coordinates: CoordinateArray[]) {\n    for(const coordinate of coordinates) {\n      this.setCoordinateValue(this._changes, coordinate, true);\n    }\n  }\n\n  applyChanges(): void {\n    const changes = this._changes;\n    this._changes = new Map();\n    let coordinate = [0, 0, 0] as CoordinateArray;\n    for(const [x, yRows] of changes) {\n      coordinate[0] = x;\n      for(const [y, zRows] of yRows) {\n        coordinate[1] = y;\n        for(const [z, newValue] of zRows) {\n          coordinate[2] = z;\n          const currentValue = this.getNestedValue(this._gridEntries, coordinate);\n          if (currentValue === newValue) continue;\n          this.setCoordinateValue(this._gridEntries, coordinate, newValue);\n          this.applyCoordinateToMinMaxFields(coordinate);\n          this.updateSurroundingNodes(coordinate, newValue ? 1 : -1);\n        }\n      }\n    }\n  }\n\n  private updateSurroundingNodes([x,y,z]: CoordinateArray, delta: number): void {\n    for(let deltaX = -1; deltaX <= 1; deltaX++) {\n      const xMap = getOrAddValue(this._surroundingNodes, x + deltaX, () => new Map());\n      for(let deltaY = -1; deltaY <= 1; deltaY++) {\n        const yMap = getOrAddValue(xMap, y + deltaY, () => new Map());\n        for(let deltaZ = -1; deltaZ <= 1; deltaZ++) {\n          if(deltaZ === 0 && deltaY === 0 && deltaX === 0) continue;\n          const value = getOrAddValue(yMap, z + deltaZ, () => 0);\n          yMap.set(z + deltaZ, value + delta);\n        }\n      }\n    }\n  }\n\n  cycle(): void {\n    const { min: xMin, max: xMax } = this._xMinMax;\n    const { min: yMin, max: yMax } = this._yMinMax;\n    const { min: zMin, max: zMax } = this._zMinMax;\n    let coordinate = [0, 0, 0] as CoordinateArray;\n    for(let x = xMin - 1; x <= xMax; x++) {\n      coordinate[0] = x;\n      for(let y = yMin - 1; y <= yMax; y++) {\n        coordinate[1] = y;\n        for(let z = zMin - 1; z <= zMax; z++) {\n          coordinate[2] = z;\n          const surroundingNodes = this.getNestedValue(this._surroundingNodes, coordinate) ?? 0;\n          const isSelfActive = this.getNestedValue(this._gridEntries, coordinate);\n          if(isSelfActive) {\n            if(surroundingNodes < 2 || surroundingNodes > 3) {\n              this.setCoordinateValue(this._changes, coordinate, false);\n            }\n          } else {\n            if(surroundingNodes === 3) {\n              this.setCoordinateValue(this._changes, coordinate, true);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  activeNodes(): number {\n    return Array.from(this._gridEntries).reduce(\n      (xSum, [,xCurr]) => xSum + Array.from(xCurr).reduce(\n        (ySum, [,yCurr]) => ySum + Array.from(yCurr.values()).filter(Boolean).length,\n        0\n      ),\n      0\n    );\n  }\n\n  private getNestedValue<T>(map: Map<number, Map<number, Map<number, T>>>, [x, y, z]: CoordinateArray): T | undefined {\n    const xRows = map.get(x);\n    if(!xRows) return undefined;\n    const yRows = xRows.get(y);\n    if(!yRows) return undefined;\n    return yRows.get(z);\n  }\n\n  private setCoordinateValue(map: Map<number, Map<number, Map<number, boolean>>>, coordinate: CoordinateArray, value: boolean) {\n    const [x,y,z] = coordinate;\n    const xMap = getOrAddValue(map, x, () => new Map());\n    const yMap = getOrAddValue(xMap, y, () => new Map());\n    yMap.set(z, value);\n  }\n\n  private applyCoordinateToMinMaxFields([x,y,z]: CoordinateArray): void {\n    this._xMinMax.update(x);\n    this._yMinMax.update(y);\n    this._zMinMax.update(z);\n  }\n}\n\nconst fileReader = new MyFileReader(input);\nconst activeCoordinates = fileReader.readLineByLine((line, xIndex) =>\n  line.split('')\n    .map((val, yIndex) => ({active: val === '#', index: yIndex}))\n    .filter((val, _, arr) => val.active)\n    .map(val => ([xIndex, val.index, 0] as CoordinateArray))\n).reduce((prev, curr) => [...prev, ...curr], [] as Array<CoordinateArray>);\n\nconst grid = new Grid();\ngrid.addActivePoint(...activeCoordinates);\ngrid.applyChanges();\n\nfor(let i = 0; i < 6; i++) {\n  grid.cycle();\n  grid.applyChanges();\n}\n\nreturn grid.activeNodes();"}}]);