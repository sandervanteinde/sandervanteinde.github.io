(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{"2czO":function(n,e,r){"use strict";r.r(e),r.d(e,"daySixteenPartTwo",function(){return i});const i="const ruleRegex = /([a-z ]+): (d+)-(d+) or (d+)-(d+)/;\n\nclass TicketRule {\n  readonly name: string;\n  private readonly _validNumbers: Set<number>;\n  constructor(rule: string) {\n    const match = ruleRegex.exec(rule);\n    if(!match) throw new Error(`Unknown ticket rule: ${rule}`);\n    const [, name, rangeOneStart, rangeOneEnd, rangeTwoStart, rangeTwoEnd] = match;\n    this.name = name;\n    this._validNumbers = new Set([\n      ...this.validNumbersForRange([Number(rangeOneStart), Number(rangeOneEnd)]),\n      ...this.validNumbersForRange([Number(rangeTwoStart), Number(rangeTwoEnd)])\n    ])\n  }\n\n  validNumbers(): Array<number> {\n    return Array.from(this._validNumbers.values());\n  }\n\n  isInRange(value: number): boolean {\n    return this._validNumbers.has(value);\n  }\n\n  private validNumbersForRange([start, end]: [number, number]): Array<number> {\n    return Array.from({length: end - start + 1}).map((_, i) => i + start);\n  }\n}\n\nfunction parseTicket(ticket: string): Array<number> {\n  const values = ticket.split(',').map(Number);\n  if(values.some(Number.isNaN)) {\n    throw new Error('Invalid ticket value found');\n  }\n  return values;\n}\nconst fileReader = new MyFileReader(input);\nconst [ticketRules, [,myTicketUnparsed], [,...nearbyTickets]] = fileReader.readEntriesSeperatedByWhiteline();\nconst myTicket = parseTicket(myTicketUnparsed);\nconst rules = ticketRules.map(rule => new TicketRule(rule));\n// all numbers that are possibly valid\nconst allValidNumbers = rules.reduce((prev, curr) => {\n  curr.validNumbers().forEach(num => prev.add(num));\n  return prev;\n}, new Set<number>());\nconst validTickets = [myTicketUnparsed, ...nearbyTickets]\n  .map(parseTicket)\n  .filter(values => values.every(value => allValidNumbers.has(value)));\n\nconst columnMappingPossibilities = new Map<TicketRule, number[]>();\n\nfor (const rule of rules) {\n  for(let i = 0; i < rules.length; i++) {\n    if (validTickets.every(ticket => rule.isInRange(ticket[i]))) {\n      let existingMapping = columnMappingPossibilities.get(rule);\n      if(!existingMapping) columnMappingPossibilities.set(rule, existingMapping = []);\n      existingMapping.push(i);\n    }\n  }\n}\nconst columnMapping = new Map<TicketRule, number>();\nif (columnMappingPossibilities.size !== rules.length) throw new Error('Failed to map all column possibilities');\nlet tryAgain = true;\nwhile(tryAgain) {\n  tryAgain = false;\n  for(const [key, value] of Array.from(columnMappingPossibilities.entries())) {\n    if(value.length === 1) {\n      const column = value[0];\n      columnMapping.set(key, column);\n      Array.from(columnMappingPossibilities.values())\n        .forEach(options => {\n          const index = options.indexOf(column);\n          if(index === -1) return;\n          options.splice(index, 1);\n        });\n        tryAgain = true;\n    }\n  }\n}\n\nif (columnMapping.size !== rules.length) throw new Error('Failed to map all columns');\n\nfor(const rule of Array.from(columnMapping.keys())) {\n  if(rule.name.startsWith('departure')) continue;\n  columnMapping.delete(rule);\n}\n\nreturn Array.from(columnMapping.values())\n  .reduce((prev, column) => {\n    return prev * myTicket[column];\n  }, 1);"}}]);