self.webpackChunk([12],{"51Uo":function(n,e,r){"use strict";r.r(e),r.d(e,"dayFourteenPartTwo",function(){return t});const t="const fileReader = new MyFileReader(input);\nconst maskRegex = /^mask = ([01X]+)$/;\nconst memoryRegex = /^mem[(d+)] = (d+)$/;\ntype MaskType = Array<'1' | '0' | 'X'>;\ninterface MemoryBuffer {\n  memory: Map<number, number>;\n  mask: MaskType;\n}\ninterface Operation {\n  perform(buffer: MemoryBuffer): void;\n}\n\nfunction fromBitArray(input: Array<'1' | '0' | 'X'>): Array<number> {\n  return input.reduce(\n    (prev, curr, index) => {\n      if (curr === '0') return prev;\n      const bitValue = Math.pow(2, index);\n      if (curr === 'X') {\n        return [...prev, ...prev.map((val) => val + bitValue)];\n      } else {\n        // 1\n        return prev.map((val) => val + bitValue);\n      }\n    },\n    [0]\n  );\n}\n\nfunction toBitArray(input: number): Array<'1' | '0'> {\n  const bitArray = [] as Array<'1' | '0'>;\n  for (let i = 0; input !== 0; i++) {\n    const bitValue = Math.pow(2, i);\n    if ((input & bitValue) === bitValue) {\n      bitArray.push('1');\n      input -= bitValue;\n    } else {\n      bitArray.push('0');\n    }\n  }\n  return bitArray;\n}\n\nfunction applyMaskToNumber(input: number, mask: MaskType): Array<number> {\n  const asBitArray = toBitArray(input);\n  return fromBitArray(\n    mask.map((val, index) => (val === '0' ? asBitArray[index] ?? '0' : val))\n  );\n}\n\nfunction setMaskOperation(maskValue: MaskType): Operation {\n  maskValue.reverse(); // easier to perform bitwise operations like this :-)\n  return {\n    perform: (buffer) => (buffer.mask = maskValue),\n  };\n}\n\nfunction setMemoryOperation(\n  memoryAddress: number,\n  memoryValue: number\n): Operation {\n  return {\n    perform: (buffer) => {\n      const memoryAddresses = applyMaskToNumber(memoryAddress, buffer.mask);\n      for (const memoryAddress of memoryAddresses) {\n        buffer.memory.set(memoryAddress, memoryValue);\n      }\n    },\n  };\n}\n\nfunction lineToOperation(line: string): Operation {\n  const memoryMatch = memoryRegex.exec(line);\n  if (memoryMatch) {\n    return setMemoryOperation(Number(memoryMatch[1]), Number(memoryMatch[2]));\n  }\n  const maskMatch = maskRegex.exec(line);\n  if (maskMatch) {\n    return setMaskOperation(maskMatch[1].split('') as MaskType);\n  }\n\n  throw new Error(`Invalid line: ${line}`);\n}\n\nconst operations = fileReader.readLineByLine(lineToOperation);\nconst context: MemoryBuffer = { mask: [], memory: new Map() };\nfor (const operation of operations) {\n  operation.perform(context);\n}\n\nconst sumOfValues = Array.from(context.memory.values()).reduce(\n  (prev, curr) => prev + curr,\n  0\n);\n\nreturn sumOfValues;"}});