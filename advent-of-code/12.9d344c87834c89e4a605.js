(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{"/ryG":function(n,t,e){"use strict";e.r(t),e.d(t,"dayEightPartTwo",function(){return o});const o="class OperationContext {\n  private _accumulator = 0;\n  private _instruction = 0;\n  private _visitedInstructions = new Set<number>();\n  get instruction(): number {\n    return this._instruction;\n  }\n  get accumulator(): number {\n    return this._accumulator;\n  }\n\n  moveNext(): void {\n    this._instruction++;\n  }\n\n  accumlate(amount: number): void {\n    this._accumulator += amount;\n    this.moveNext();\n  }\n\n  jump(amount: number): void {\n    this._instruction += amount;\n  }\n\n  hasVisitedCurrentInstructionBefore(): boolean {\n    if (this._visitedInstructions.has(this._instruction)) {\n      return true;\n    }\n\n    this._visitedInstructions.add(this._instruction);\n    return false;\n  }\n}\n\ninterface Operation {\n  perform(ctx: OperationContext): void;\n  amount: number;\n}\n\nclass AccOperation implements Operation {\n  constructor(readonly amount: number) {}\n  perform(ctx: OperationContext): void {\n    ctx.accumlate(this.amount);\n  }\n}\n\nclass JmpOperation implements Operation {\n  constructor(readonly amount: number) {}\n  perform(ctx: OperationContext): void {\n    ctx.jump(this.amount);\n  }\n}\n\nclass NopOperation implements Operation {\n  constructor(readonly amount: number) {}\n  perform(ctx: OperationContext): void {\n    ctx.moveNext();\n  }\n}\nconst matchStatement = /([a-z]{3}) ([+-]d+)/;\nconst fileReader = new MyFileReader(input);\nconst operations = fileReader.readLineByLine<Operation>((line) => {\n  const [, op, amount] = line.match(matchStatement)!;\n  const amountAsNum = Number(amount);\n  switch (op) {\n    case 'acc':\n      return new AccOperation(amountAsNum);\n    case 'jmp':\n      return new JmpOperation(amountAsNum);\n    case 'nop':\n      return new NopOperation(amountAsNum);\n    default:\n      throw new Error(`Invalid operation\n${op}`);\n  }\n});\n\nfor (let i = 0; i < operations.length; i++) {\n  const corruptedOperation = operations[i];\n  if (corruptedOperation instanceof AccOperation) continue; // these are not corrupted\n  const newOperationSet = [...operations];\n  newOperationSet[i] =\n    corruptedOperation instanceof NopOperation\n      ? new JmpOperation(corruptedOperation.amount)\n      : new NopOperation(corruptedOperation.amount);\n  const ctx = new OperationContext();\n  while (!ctx.hasVisitedCurrentInstructionBefore()) {\n    const instructionNumber = ctx.instruction;\n    if (instructionNumber === newOperationSet.length - 1) {\n      // LAST INSTRUCTION REACHED!\n      const instruction = newOperationSet[instructionNumber];\n      instruction.perform(ctx);\n      return ctx.accumulator;\n    }\n    if (instructionNumber >= newOperationSet.length) continue; // this program is invalid. We are past the last instruction.\n    const instruction = newOperationSet[instructionNumber];\n    instruction.perform(ctx);\n  }\n}\n\nthrow new Error('Result not found');"}}]);